---
timestamp: 'Sat Oct 18 2025 19:46:54 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251018_194654.a1eaca71.md]]'
content_id: 2c15eabab0734facad6644819fb7e2b4760e6f13a4ff7357432ec476426f5d0b
---

# Commenting

Every action should have a comment including its signature, its requirements, and effects:

```typescript
  /**
   * createLabel (name: String): (label: Label)
   *
   * **requires** no Label with the given `name` already exists
   *
   * **effects** creates a new Label `l`; sets the name of `l` to `name`; returns `l` as `label`
   */
```

## Concept: UserAuthentication

**purpose**
Authenticate users by credential.

**principle**
After registering, logging in with the same credentials authenticates you; logging out ends that authentication.

**state**

```
a set of Users with
  – username String
  – passwordHash String
```

**actions**

* `register (username: String, password: String) : (user: User | error: String)`

  * **requires** username not already taken
  * **effects** creates user; stores password hash
* `login (username: String, password: String) : (user: User | error: String)`

  * **requires** user exists and password matches
  * **effects** returns the corresponding user
* `changePassword (user: User, oldPassword: String, newPassword: String) : ( | error: String)`

  * **requires** user exists and oldPassword matches
  * **effects** updates passwordHash

**queries**

* `_byUsername (username: String) : (user: User)`

  * **requires** true
  * **effects** returns user if present

***

## Concept: UserProfile \[User]

**purpose**
Store display information about a user.

**principle**
Calling `setProfile` with a new name/bio/avatar updates how the profile appears.

**state**

```
a set of Users with
  – name String
  – bio String
  – avatar Image?
```

**actions**

* `setProfile (user: User, name?: String, bio?: String, avatar?: Image) : ( )`

  * **requires** user exists
  * **effects** updates only provided fields; others unchanged

**queries**

* `_profile (user: User) : (name: String, bio: String, avatar: Image?)`

  * **requires** user exists
  * **effects** returns current profile fields

***

## Concept: Membership \[User]

**purpose**
Represent eligibility for ordering at the student-run cafe.

**principle**
Active members can place orders; deactivated members cannot.

**state**

```
a set of Users with
  – isActive Boolean
  – joinedDate Time
```

**actions**

* `activate (user: User) : ( )`

  * **requires** user exists
  * **effects** sets isActive := true; sets joinedDate if unset
* `deactivate (user: User) : ( )`

  * **requires** user exists
  * **effects** sets isActive := false

**queries**

* `_isActive (user: User) : (isActive: Boolean)`

  * **requires** user exists
  * **effects** returns membership flag
* `_joinedDate (user: User) : (joinedDate: Time?)`

  * **requires** user exists
  * **effects** returns joinedDate if any

***

## Concept: Menu \[Item, Option, Choice]

**purpose**
Define items and their configurable options/choices (no pricing).

**principle**
Operators attach **temperature** (required, maxChoices=1) and **milk** (optional, maxChoices=1) to **Latte**; only **temperature** to **Americano**. The POS shows the right choices and blocks disallowed combos.

**state**

```
a set of Items with
  – name String
  – description String
  – isActive Boolean

a set of Options with
  – name String
  – required Boolean
  – maxChoices Number (≥1)

a set of Choices with
  – option Option
  – name String
  – isActive Boolean

a set of Applicabilities with
  – item Item
  – option Option
  – disallowedChoices Set<Choice>
```

**actions**

* `createItem (name: String, description: String) : (item: Item)`

  * **requires** true
  * **effects** creates active item
* `setItemActive (item: Item, isActive: Boolean) : ( )`

  * **requires** item exists
  * **effects** sets isActive
* `createOption (name: String, required: Boolean, maxChoices: Number) : (option: Option)`

  * **requires** maxChoices ≥ 1
  * **effects** creates option
* `createChoice (option: Option, name: String) : (choice: Choice)`

  * **requires** option exists
  * **effects** creates active choice under option
* `attachOption (item: Item, option: Option) : ( )`

  * **requires** not already attached
  * **effects** adds Applicability(item, option) with empty disallowedChoices
* `detachOption (item: Item, option: Option) : ( )`

  * **requires** Applicability exists
  * **effects** removes it
* `disallowChoice (item: Item, option: Option, choice: Choice) : ( )`

  * **requires** Applicability(item, option) and choice belongs to option
  * **effects** adds choice to disallowedChoices
* `allowChoice (item: Item, option: Option, choice: Choice) : ( )`

  * **requires** choice currently disallowed
  * **effects** removes from disallowedChoices

**queries**

* `_optionsForItem (item: Item) : (option: {id: Option, required: Boolean, maxChoices: Number})`

  * **requires** item exists
  * **effects** returns attached options
* `_choicesFor (item: Item, option: Option) : (choice: {id: Choice, name: String})`

  * **requires** Applicability(item, option)
  * **effects** returns active choices excluding disallowedChoices
* `_isSelectionSetValid (item: Item, selections: {option: Option, choice: Choice}[]) : (ok: Boolean, reason: String)`

  * **requires** item exists
  * **effects** true iff each selected option is attached to item; each choice belongs to its option and is not disallowed; all attached required options are present; per-option maxChoices respected

***

## Concept: Order \[User, Item, Option, Choice]

**purpose**
Capture a member’s order lifecycle and chosen customizations (no pricing).

**principle**
Scanning a valid member starts a **pending** order; barista adds a **Latte** with **hot** and **oat** (valid); submitting, then completing, marks the order **completed**; canceled orders stop accepting changes.

**state**

```
a set of Orders with
  – user User
  – status {pending, completed, canceled}
  – createdAt Time

a set of OrderLines with
  – order Order
  – item Item
  – qty Number
  – displayItemName String

a set of SelectedChoices with
  – line OrderLine
  – option Option
  – choice Choice
  – displayOptionName String
  – displayChoiceName String
```

**actions**

* `open (user: User) : (order: Order)`

  * **requires** true *(membership gating via sync)*
  * **effects** creates order with status := pending
* `addItem (order: Order, item: Item, qty: Number, selections: {option: Option, choice: Choice}[]) : (line: OrderLine)`

  * **requires** order exists and status = pending *(validity checked via sync)*
  * **effects** creates line; copies displayItemName; stores SelectedChoices with copied display names
* `submit (order: Order) : ( )`

  * **requires** order exists and status = pending and order has ≥ 1 line
  * **effects** lifecycle only
* `complete (order: Order) : ( )`

  * **requires** order exists and status = pending
  * **effects** sets status := completed
* `cancel (order: Order) : ( )`

  * **requires** order exists and status = pending
  * **effects** sets status := canceled

**queries**

* `_lines (order: Order) : (line: {id: OrderLine, item: Item, qty: Number, selections: {option: Option, choice: Choice}[]})`

  * **requires** order exists
  * **effects** returns structured lines + selections
* `_status (order: Order) : (status: String)`

  * **requires** order exists
  * **effects** returns current status

***

## Concept: CustomerFeedback \[User, Order]

**purpose**
Collect user comments about completed orders for quality tracking and improvement.

**principle**
After an order is **completed**, the user (or barista on behalf of the user) can record a feedback comment linked to that order; feedback for non-completed or canceled orders is rejected.

**state**

```
a set of Feedbacks with
  – user User
  – order Order
  – comment String
  – createdAt Time
```

**actions**

* `create (user: User, order: Order, comment: String) : (feedbackId)`

  * **requires** true *(completion enforced via sync)*
  * **effects** creates feedback {user, order, comment, createdAt := now}

**queries**

* `_forOrder (order: Order) : (feedback: {user: User, comment: String, createdAt: Time})`

  * **requires** true
  * **effects** returns feedback for order
* `_forUser (user: User) : (feedback: {order: Order, comment: String, createdAt: Time})`

  * **requires** true
  * **effects** returns feedback left by user

***

## Pseudo-Concept: Request (UI/Intent Surface)

**actions (intents)**

* `scanQR (user: User) : ( )`

  * **requires** decoder provided user
  * **effects** emits intent to open order for user
* `addItem (order: Order, item: Item, qty: Number, selections: {option: Option, choice: Choice}[]) : ( )`

  * **requires** UI provided params
  * **effects** emits intent to add validated line
* `submit (order: Order) : ( )`

  * **requires** UI provided order
  * **effects** emits intent to submit
* `leaveFeedback (user: User, order: Order, comment: String) : ( )`

  * **requires** UI provided params
  * **effects** emits intent to create feedback

***

## Synchronizations

**1) Scan → open pending order (gate by membership)**

```
sync OpenOrderOnScan
when
  Request.scanQR (user)
where
  in Membership: _isActive(user) -> (isActive)
  isActive = true
then
  Order.open (user) -> (order)
```

**2) Validate selections against Menu before adding a line**

```
sync ValidateSelectionsBeforeAdd
when
  Request.addItem (order, item, qty, selections)
where
  in Menu: _isSelectionSetValid(item, selections) -> (ok, reason)
  ok = true
then
  Order.addItem (order, item, qty, selections)
```

**3) Submission guard: must have ≥ 1 line**

```
sync GuardSubmit
when
  Request.submit (order)
where
  in Order: _lines(order) -> (line) exists
then
  Order.submit (order)
```

**4) Allow feedback only after completion**

```
sync AllowFeedbackOnCompletedOrders
when
  Request.leaveFeedback (user, order, comment)
where
  in Order: _status(order) -> (status)
  status = "completed"
then
  CustomerFeedback.create (user, order, comment)
```
